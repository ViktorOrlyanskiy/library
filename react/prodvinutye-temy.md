# Продвинутые темы

## Доступность контента

1. HTML-атрибуты aria-\*
2. Семантическая вёрстка
3. Определение языка
4. Заголовок страницы
5. Цветовая контрастность

#### Доступность контента в формах

1. Подписи полей ввода в формах
2. Сообщения об ошибках при заполнении формы

#### Управление фокусом

1. Фокус клавиатуры и контур элемента
2. Механизмы быстрого перехода к нужному контенту
3. Программное управление фокусом

#### Инструменты тестирования доступности

1. Тестирование клавиатуры
2. Инструменты разработчика (eslint-plugin-jsx-a11y)
3. Тестирование доступности контента в браузере
4. Экранные считывающие устройства

{% embed url="https://ru.reactjs.org/docs/accessibility.html" %}

## Контекст

Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева **React-компонентов** (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).

{% hint style="warning" %}
Если вы хотите избавиться от передачи некоторых пропсов на множество уровней вниз, обычно композиция компонентов является более простым решением, чем контекст.
{% endhint %}

{% hint style="danger" %}
Все потребители, которые являются потомками **Provider**, будут повторно рендериться, как только проп **value у Provider** изменится. Потребитель (включая **.contextType** и **useContext**) перерендерится при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью **shouldComponentUpdate**.
{% endhint %}

{% embed url="https://ru.reactjs.org/docs/context.html" %}

## ErrorBoundary

**Границы ошибок** — это компоненты **React**, которые отлавливают ошибки **JavaScript** в любом месте деревьев их дочерних компонентов, сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.

{% hint style="info" %}
Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов, расположенных под ними.
{% endhint %}

#### Предохранители не поймают ошибки в:

1. обработчиках событий
2. асинхронном коде (например колбэках из setTimeout или requestAnimationFrame)
3. серверном рендеринге (Server-side rendering)
4. самом предохранителе (а не в его дочерних компонентах).

{% hint style="warning" %}
Начиная с **React 16**, ошибки, не отловленные ни одним из предохранителей, будут приводить к размонтированию всего дерева компонентов React.
{% endhint %}

Это компонент класса. Он хранит состояние, не используя хуки: он получает доступ к определенным методам, которые вызываются в тот или иной момент на протяжении жизненного цикла компонента. **Один из таких методов — getDerivedStateFromError.** Он вызывается, когда в процессе рендеринга где-либо в дочерних элементах происходит ошибка. При возникновении ошибки устанавливается значение **state.error**. В случае ошибки отображается компонент **fallback**, и эта ошибка передается компоненту как свойство.

{% code lineNumbers="true" %}
```jsx
import React, { ErrorInfo, Suspense } from "react";
import { PageError } from "@/widgets/PageError";
import { PageLoader } from "@/widgets/PageLoader";

interface ErrorBoundaryProps {
    children: React.ReactNode;
}
interface ErrorBoundaryState {
    hasError: boolean;
}

export class ErrorBoundary extends React.Component<
    ErrorBoundaryProps,
    ErrorBoundaryState
> {
    constructor(props: ErrorBoundaryProps) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error: Error) {
        // Update state so the next render will show the fallback UI.
        return { hasError: true };
    }

    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        // You can also log the error to an error reporting service
        console.log(error, errorInfo);
    }

    render() {
        const { hasError } = this.state;
        const { children } = this.props;
        if (hasError) {
            // You can render any custom fallback UI
            return (
                <Suspense fallback={<PageLoader />}>
                    <PageError />
                </Suspense>
            );
        }

        return children;
    }
}
```
{% endcode %}

{% embed url="https://ru.reactjs.org/docs/error-boundaries.html" %}

## Suspense

Он работает так же, как компонент **ErrorBoundary**. Мы оборачиваем его вокруг определенных компонентов в дереве. Вместо того чтобы возвращаться к сообщению об ошибке при возникновении ошибки, компонент **Suspense** отображает сообщение загрузки, когда происходит отложенная загрузка.

{% hint style="warning" %}
Важно знать, что, когда мы запускаем промис (пробрасываем наверх), он перехватывается компонентом **Suspense** и мы переходим в состояние ожидания, пока промис не будет выполнен.
{% endhint %}

## Фрагменты

**Фрагменты** — это относительно новая функция **React**, которая устраняет необходимость в дополнительных тегах-оболочках, засоряющих **DOM**.

Фрагменты, объявленные с помощью **\<React.Fragment>**, могут иметь ключи. **key** — это единственный атрибут, допустимый у **Fragment**

Существует сокращённая запись объявления фрагментов. Она выглядит как пустые теги **<>\</>**. Однако такая запись не поддерживает ключи или атрибуты.

## Компоненты высшего порядка

Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.

{% hint style="info" %}
Заметьте, что **HOC** ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого **HOC** оборачивает оригинальный компонент в контейнер посредством композиции. **HOC** **является чистой функцией без побочных эффектов**.
{% endhint %}

{% code lineNumbers="true" %}
```jsx
function logProps(WrappedComponent) {
  return class extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('Текущие пропсы: ', this.props);
      console.log('Предыдущие пропсы: ', prevProps);
    }
    render() {
      // Оборачиваем компонент в контейнер без мутаций. Супер!
      return <WrappedComponent {...this.props} />;
    }
  }
}
```
{% endcode %}

{% hint style="info" %}
**Соглашение:** передавайте посторонние пропсы оборачиваемому компоненту **HOC** добавляют компонентам функциональность, но они не должны менять их оригинальное предназначение. Ожидается, что интерфейс компонента, который вы возвращаете из **HOC**, будет похож на интерфейс оборачиваемого компонента.
{% endhint %}

{% hint style="info" %}
**Соглашение:** **HOC** передают оборачиваемому компоненту все пропсы, кроме рефов. **ref** на самом деле не проп, как, например, **key**, и поэтому иначе обрабатывается **React.** Реф элемента, созданного компонентом из **HOC**, будет указывать на экземпляр ближайшего в иерархии контейнера, а не на оборачиваемый компонент.&#x20;

**Вы можете решить эту проблему с помощью API-метода React.forwardRef**
{% endhint %}

{% embed url="https://ru.reactjs.org/docs/higher-order-components.html" %}

## Порталы

{% code lineNumbers="true" %}
```jsx
ReactDOM.createPortal(child, container)
```
{% endcode %}

{% hint style="info" %}
Событие, сгенерированное изнутри портала, будет распространяться к родителям в содержащем **React-дереве**, даже если эти элементы не являются родительскими в **DOM-дереве**.
{% endhint %}

{% embed url="https://ru.reactjs.org/docs/portals.html" %}

## Profiler

**Profiler** измеряет то, как часто рендерится React-приложение и какова «стоимость» этого. Его задача — помочь найти медленные части приложения, которые можно оптимизировать (например, через мемоизацию).

**Profiler** может быть добавлен в любую часть React-дерева для измерения стоимости рендеринга этой части. Он принимает два пропа: **id (string)** и **колбэк onRender (function)**, который React вызывает каждый раз, когда компонент внутри дерева «фиксирует» обновление.

{% code lineNumbers="true" %}
```jsx
render(
  <App>
    <Profiler id="Navigation" onRender={callback}>
      <Navigation {...props} />
    </Profiler>
    <Main {...props} />
  </App>
);
```
{% endcode %}

{% embed url="https://ru.reactjs.org/docs/profiler.html" %}

## Алгоритм сравнения

#### Элементы различных типов

Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Переходы от \<a> к \<img> , или от к , или от \<Article> к \<Comment> приведут к полному перестроению.

#### Элементы одного типа

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.

{% hint style="info" %}
React полагается на эвристику, следовательно, если предположения, на которых она основана, не соблюдены, пострадает производительность.
{% endhint %}

1. Алгоритм не будет пытаться сопоставить поддеревья компонентов разных типов. Если вы заметите за собой, что пытаетесь чередовать компоненты разных типов с очень схожим выводом, то желательно сделать их компонентами одного типа. На практике мы не выявили с этим проблем.
2. Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью Math.random()) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов.

{% embed url="https://ru.reactjs.org/docs/reconciliation.html" %}

## Рефы

#### Ситуации, в которых использование рефов является оправданным:

1. Управление фокусом, выделение текста или воспроизведение медиа.
2. Императивный вызов анимаций.
3. Интеграция со сторонними DOM-библиотеками.

{% hint style="warning" %}
Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом.
{% endhint %}

{% hint style="info" %}
По умолчанию нельзя использовать атрибут ref с функциональными компонентами, потому что для них не создаётся экземпляров: Тем не менее, можно использовать атрибут ref внутри функционального компонента при условии, что он ссылается на DOM-элемент или классовый компонент
{% endhint %}

#### Колбэк-рефы

Вместо того, чтобы передавать атрибут ref созданный с помощью createRef(), вы можете передать функцию. Данная функция получит экземпляр React-компонента или HTML DOM-элемент в качестве аргумента, которые потом могут быть сохранены или доступны в любом другом месте.



## Рендер-пропсы

Компонент с рендер-пропсом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера. Иными словами, рендер-пропc — функция, которая сообщает компоненту что необходимо рендерить.

{% code lineNumbers="true" %}
```jsx
<DataProvider render={data => (
  <h1>Привет, {data.target}</h1>
)}/>
```
{% endcode %}

{% hint style="warning" %}
Использование рендер-пропcа может свести на нет преимущество, которое даёт **React.PureComponent**, если вы создаёте функцию внутри метода **render**
{% endhint %}

{% embed url="https://ru.reactjs.org/docs/render-props.html" %}

## StrictMode

#### На данный момент StrictMode помогает в:

1. Обнаружении небезопасных методов жизненного цикла&#x20;
2. Предупреждении об использовании устаревшего API строковых реф&#x20;
3. Предупреждении об использовании устаревшего метода findDOMNode&#x20;
4. Обнаружении неожиданных побочных эффектов&#x20;
5. Обнаружении устаревшего API контекста&#x20;
6. Обеспечение переиспользованного состояния

{% embed url="https://ru.reactjs.org/docs/strict-mode.html" %}
